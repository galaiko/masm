	.include "tn13def.inc"   ; ?спользуем ATtiny 13
;= Start macro.inc ========================================================
 
; Место под макросы 
 
;= End macro.inc  =========================================================
 	
; RAM =====================================================================
	.DSEG								; Сегмент ОЗУ
			.def null=r1				;тут всегда нули, чтобы тормозить таймер
			;.def calibr=r10 			;калибровочное значение сенсора
			.def sensLow=r11			;калибровочное+порог
			.def step=r12				;гистерезис
			.def sensWork=r13			;рабочее значение сенсора
			.def c_cicl=r14				;счетчик циклов для мигания стартовым светом
			.def c_flash=r15			;счетчик миганий стартовым диодом
			.def temp=r16			  	;рабочий регистр
			.def delayL=r17				;младший разряд счетчика
			.def delayM=r18				;средний разряд счетчика
			.def delayH=r19				;старший разряд счетчика
			.def red=r20		  		;яркость красного канала
			.def green=r21				;яркость зеленого канала
			.def blue=r22		  		;яркость синего канала
			.def bufred=r23				;буфер красного для Ш?М
			.def bufgreen=r24			;буфер зеленого для Ш?М
			.def bufblue=r25			;буфер синего для Ш?М
			;.def counter=r26;счетчик для Ш?М. ?спользовать XL
			;.def loop_count=r27;счетный регистр для цикла цветов.?спользовать XH
	;***загружаем число 30 720 или $007800, что обеспечит задержку в 16 мс***
			.equ timeL=00				;младший разряд количества циклов 
			.equ timeM=0x78				;средний разряд количества циклов
			.equ timeH=00				;старший разряд количества циклов
; END RAM =================================================================	
 
; FLASH ===================================================================
	.CSEG								; Кодовый сегмент
		
; Interrupts ==============================================================
			.org $000	    			;reset
			rjmp reset
			.org $001					;INT0 External Interrupt 0
			reti
			.org $002					;PCI0 External Interrupt Request 0
			reti
			.org $003					;OVF0 Timer/Counter0 Overflow
			rjmp pwm
			.org $004					;ERDY EEPROM Ready
			reti
			.org $005					;ACI Analog Comparator
			reti
			.org $006					;OC0A Timer/Counter Compare Match A
			reti
			.org $007					;OC0B Timer/Counter Compare Match B
			reti
			.org $008					;WDT Watchdog Time-out
			rjmp wd
			.org $009					;ADCC ADC Conversion Complete
			reti		
			.ORG   INT_VECTORS_SIZE		;конец таблицы прерываний

	;***** Обработка прерывания по переполнению таймера*****
pwm:		push temp					;сохраняем temp в стеке
			in temp,sreg				;сохраняем sreg в стеке
			push temp
			inc XL 						;увеличиваем внутренний счетчик Ш?М
			cpi XL,0					;проверка на переход счетчика через 0. 
			brne check_r				;если нет, то переход на проверку каналов
	;***если да, то загружаем новые уровни яркости***
			mov bufred,red 				;для красного
			mov bufgreen,green			;для зеленого
			mov bufblue,blue 			;для синего
			ldi temp,0b00000111			;включаем все три канала rgb
			out portb,temp
check_r:	cp XL,bufred				;проверяем  канал
			brne check_g				;если счетчик не равен, проверяем дальше
			cbi portb,0 				;если счетчик равен - гасим соответствующий
check_g:	cp XL,bufgreen
			brne check_b
			cbi portb,1	
check_b:	cp XL,bufblue
			brne exit
			cbi portb,2
exit:		pop temp					;вынимаем из стека sreg
			out sreg,temp
			pop temp					;вынимаем из стека temp
			reti
	;***** Обработка прерывания watchdog*****
	;***** задача опросить сенсор и записать значение*****
wd:			mov sensWork,null			;чистим рабочее значение сенсора
			sbi ddrb,4					;переводим pb4 в режим выход
			cbi portb,4					;на всякий случай подаем туда 0 - разрядим сенсор
			ldi temp,0b00000001
			out tccr0b,temp 			;запускаем таймер на тактовой
			cbi ddrb,4 					;переводим pb4 во вход Hi-Z, начинается заряд сенсора
scan_4_w:	sbis pinb,4 				;проверяем 1 на входе pb4
			rjmp scan_4_w				;возврат на проверку, если < 1
			ldi temp,0b00000000
			out tccr0b,temp 			;стоп таймер
			sbi ddrb,4					;переводим pb4 в режим выход
			cbi portb,4					;подаем туда 0 - разрядим сенсор
			in sensWork,tcnt0			;считываем показания счетчика 
			out tcnt0,null 				;очищаем показания счетчика	
			reti
; End Interrupts ===========================================================

; ===== Инициализация стека ================================================
Reset:		LDI R16,Low(RAMEND)	
			OUT SPL,R16

; ===== Очистка памяти и всех регистров=====================================
	; Start coreinit.inc
RAM_Flush:	LDI	ZL,Low(SRAM_START)	
			LDI	ZH,High(SRAM_START)
			CLR	R16					
Flush:		ST 	Z+,R16				
			CPI	ZH,High(RAMEND+1)	
			BRNE	Flush			
			CPI	ZL,Low(RAMEND+1)	
			BRNE	Flush
 
			CLR	ZL			
			CLR	ZH
			CLR	R0
			CLR	R1
			CLR	R2
			CLR	R3
			CLR	R4
			CLR	R5
			CLR	R6
			CLR	R7
			CLR	R8
			CLR	R9
			CLR	R10
			CLR	R11
			CLR	R12
			CLR	R13
			CLR	R14
			CLR	R15
			CLR	R16
			CLR	R17
			CLR	R18
			CLR	R19
			CLR	R20
			CLR	R21
			CLR	R22
			CLR	R23
			CLR	R24
			CLR	R25
			CLR	R26
			CLR	R27
			CLR	R28
			CLR	R29
	; End coreinit.inc

; Internal Hardware Init  ==================================================
	;*** pb0 - красный, pb1 - зеленый, pb2 - синий, pb4 - сенсор***
			ldi temp,0b00000111			;pb0, pb1, pb2 - определяем выходами
			out ddrb,temp 				;
			ldi temp,0b00000000			;выключаем выводы pb0, pb1, pb2
			out portb,temp 				;pb4 - в Hi-Z
			ldi temp,0b00001111			;загружаем значение порога (рандомно) 
			mov step,temp 				;в step
			clr temp 					;чистим temp
	;***** Инициализируем сон в режиме Power-Down
			in temp,mcucr    	    	;загружаем mcucr
			ori temp,1<<sm1				;активируем режим маской ob00010000
			out mcucr,temp				;выгружаем mcucr обатно
	;***** Сбрасываем флаг прерывания wdrf в регистре mcusr
			clr temp					;чистим регистр
			wdr							;сбрасываем собаку
			in temp,mcusr				
			andi temp,~(1<<wdrf)		;сбрасываем бит wdrf
			out mcusr,temp

; End Internal Hardware Init ===============================================


; External Hardware Init  ==================================================
 

; End Internal Hardware Init ===============================================

 
; Run ======================================================================
				

; End Run ==================================================================


; Main =====================================================================
	;*****Для индикации процесса калибровки, мигаем диодами поочередно*****
			ldi temp,0b00000011 		;загружаем число 3-число циклов мигания
			mov c_flash,temp 			;мигать будет 3 раза по 1,5 сек
strob: 		sbi portb,1					;зажигаем зеленый
			ldi temp,0b00001111			
			mov c_cicl,temp 			;задаем время свечения:15 циклов~1/4 сек
			rcall delay 				;запускаем отсчет
			cbi portb,1					;гасим зеленый
			ldi temp,0b00001111			
			mov c_cicl,temp 			;задаем время погасшего:15 циклов~1/4 сек
			rcall delay 				;запускаем отсчет
			sbi portb,0 				;зажигаем красный
			ldi temp,0b00001111			
			mov c_cicl,temp 			;задаем время свечения:15 циклов~1/4 сек
			rcall delay 				;запускаем отсчет
			cbi portb,0					;гасим красный
			ldi temp,0b00001111			
			mov c_cicl,temp 			;задаем время погасшего:15 циклов~1/4 сек
			rcall delay 				;запускаем отсчет
			sbi portb,2 				;зажигаем синий
			ldi temp,0b00001111			
			mov c_cicl,temp 			;задаем время свечения:15 циклов~1/4 сек
			rcall delay 				;запускаем отсчет
			cbi portb,2					;гасим синий
			ldi temp,0b00001111			
			mov c_cicl,temp 			;задаем время погасшего:15 циклов~1/4 сек
			rcall delay 				;запускаем отсчет
			dec c_flash
			brne strob 					
	;*****Перед калибровкой зажигаем белый цвет*****
			sbi portb,1					;зажигаем зеленый
			sbi portb,0 				;зажигаем красный
			sbi portb,2 				;зажигаем синий
	;*****Калибровка сенсора*****
			sbi ddrb,4					;переводим pb4 в режим выход
			cbi portb,4					;на всякий случай подаем туда 0 - разрядим сенсор
			ldi temp,0b00000001
			out tccr0b,temp 			;запускаем таймер на тактовой
			cbi ddrb,4 					;переводим pb4 во вход Hi-Z, начинается заряд сенсора
scan_4_c:	sbis pinb,4 				;проверяем 1 на входе pb4
			rjmp scan_4_c				;возврат на проверку, если < 1
			ldi temp,0b00000000
			out tccr0b,temp 			;стоп таймер
			sbi ddrb,4					;переводим pb4 в режим выход
			cbi portb,4					;подаем туда 0 - разрядим сенсор
			in sensLow,tcnt0			;считываем показания счетчика 
			out tcnt0,null 				;очищаем показания счетчика
			add sensLow,step 			;добавим к значению сенсора гистерезис 
			;*****Калибровка закончена*****
	;*****После калибровки выдержим паузу в 1 сек и погасим диоды. Переход в рабочее состояние****
			ldi temp,0b01000001			
			mov c_cicl,temp 			;задаем время погасшего:65 циклов~1 сек
			rcall delay 				;запускаем отсчет
			cbi portb,1					;гасим зеленый
			cbi portb,0					;гасим красный
			cbi portb,2					;гасим синий
	;*****Активируем watchdog и уходим в сон*****
	;***** Разрешаем сон
scan:		in temp,mcucr				;считываем mcucr
			ori temp,1<<se				;накладываем маску 0b00100000
			out mcucr,temp				;грузим обратно
		;Запускаем wd 
			cli							;запрещаем прерывания
			wdr							;сбрасываем wd
			in temp,wdtcr			 	;считываем регистр управления wd
			ori temp,(1<<wdce)|(1<<wdtie);пишем 1 в биты 4 и 6
			out wdtcr,temp				;грузим регистр обратно
			ldi temp,(1<<wdtie)|(1<<wdp0)|(1<<wdp2);предделитель на 0.5с. 
			out wdtcr,temp				;вроде бы старт...
			sei							;разрешаем прерывания
			sleep 						;засыпаем
		;Выключаем wd 
			cli 						;запрещаем прерывания
			wdr 						;сбрасываем watchdog
			in temp,wdtcr			 	;считываем регистр управления wd
			ori temp,(1<<wdce)|(1<<wdtie);пишем 1 в биты 4 и 6
			out wdtcr,temp				;грузим регистр обратно
			ldi temp,(0<<wdtie)			;еще раз пишем wdtie
			out wdtcr,temp 				;вроде бы стоп...
			sei							;разрешаем прерывания
		;Запрещаем сон
			in temp,mcucr
			andi temp,~(1<<se) 			;накладываем маску 0b11011111
			out mcucr,temp
	;***** Сверяем сенсор с эталоном. Если касания нет - в сон *****
			clc 						;очищаем флаг С на всякий случай
			cp sensWork,sensLow 		;сравниваем показания сенсора с калибровочным 
			brlo scan 					;возвращаемся в сон
	;*****Если касание зафиксировано - держим паузу ~300мс и после проверки начинаем вкл*****
	;***** Если касание ложное - опять спать****
			ldi temp,0b00010100 		; загружаем 20 для паузы в 320 мс
			mov c_cicl,temp 			
			rcall delay 				;запускаем отсчет
			rcall scan_pro				;сканируем сенсор
	;***** Сверяем сенсор с эталоном. Если касания нет - в сон *****
			clc 						;очищаем флаг С на всякий случай
			cp sensWork,sensLow 		;сравниваем показания сенсора с калибровочным 
			brlo scan 					;возвращаемся в сон
	;***** Если касание есть - начинаем светить диодом *****
	;*****Начало работы светодиода*****
			ldi red,0b00000000			;стартовый 0 яркости в красный
			ldi green,0b00000000		;стартовый 0 яркости в зеленый
			ldi blue,0b00000000			;стартовый 0 в синий
		;***инициализация прерываний и таймера в ШИМ***
			ldi temp,(1<<toie0)			;разрешаем прерывания по переполнению таймера
			out timsk0,temp
			sei							;разрешаем прерывания вообще
			ldi temp,0b00000001			;запускаем таймер с предделителем 0
			out tccr0b,temp				
	;*****Всё начинается с плавного зажигания красного. red_c - красный цикл*****
red_c:		ldi XH,255
start:		inc red 					;на единицу увеличиваем яркость red
			ldi temp,0b00000001			
			mov c_cicl,temp 			;задаем время свечения:1 цикл - 16 мс
			rcall delay 				;запускаем отсчет
			dec XH						;уменьшаем счетчик циклов цветов
			brne start
			clr XH						;чистим счетчик циклов цветов
	;*****Здесь место для блока проверки сенсора и уход в сон через затухание красного*****
	;*****Перед проверкой запретить прерывания*****
	;***** В этот момент красный диод продолжает светить!*****
main:		ldi temp,0b00000000
			out tccr0b,temp 			;стоп таймер
			cli 						;запрещаем прерывания
	;***** Опрашиваем сенсор *****		
			rcall scan_pro				
			clc 						;очищаем флаг С на всякий случай
			cp sensWork,sensLow 		;сравниваем показания сенсора с калибровочным 
			brlo red_sleep				;идем спать
			ldi temp,0b00000001			
			out tccr0b,temp				;запускаем таймер
			sei							;разрешаем прерывания
			rjmp green_c 				;перескакиваем на продолжение свечения
	;***** Если касания в красном цикле не обнаружено,
	;уменьшаем в ноль красный и засыпаем *****
red_sleep:	ldi temp,0b00000001			
			out tccr0b,temp				;запускаем таймер
			sei							;разрешаем прерывания
			ldi XH,255
low_red:	dec red 					;на единицу уменьшаем red
			ldi temp,0b00000001			
			mov c_cicl,temp 			;задаем время свечения:1 цикл - 16 мс
			rcall delay 				;запускаем отсчет
			dec XH						;уменьшаем счетчик циклов цветов
			brne low_red
			clr XH						;чистим счетчик циклов цветов
			rjmp scan 					;уходим в сон
	;*****Начинается смена цветов. Первый блок: от красного к зеленому
	;green_c - зеленый цикл
green_c:	ldi XH,255
loop_gr:	inc green 					;на единицу увеличиваем яркость green
			dec red 					;на единицу уменьшаем red
			ldi temp,0b00000001			
			mov c_cicl,temp 			;задаем время свечения:1 цикл - 16 мс
			rcall delay 				;запускаем отсчет
			dec XH						;уменьшаем счетчик циклов цветов
			brne loop_gr
			clr XH						;чистим счетчик циклов цветов
	;*****Здесь место для блока проверки сенсора и уход в сон через затухание зеленого*****
	;*****Перед проверкой запретить прерывания*****
	;***** В этот момент зеленый диод продолжает светить!*****
			ldi temp,0b00000000
			out tccr0b,temp 			;стоп таймер
			cli 						;запрещаем прерывания
	;***** Опрашиваем сенсор *****		
			rcall scan_pro				
			clc 						;очищаем флаг С на всякий случай
			cp sensWork,sensLow 		;сравниваем показания сенсора с калибровочным 
			brlo green_sleep			;идем спать
			ldi temp,0b00000001			
			out tccr0b,temp				;запускаем таймер
			sei							;разрешаем прерывания
			rjmp blue_c 				;перескакиваем на продолжение свечения
	;***** Если касания в зеленом цикле не обнаружено,
	;уменьшаем в ноль зеленый и засыпаем *****
green_sleep:ldi temp,0b00000001			
			out tccr0b,temp				;запускаем таймер
			sei							;разрешаем прерывания
			ldi XH,255
low_green:	dec green 					;на единицу уменьшаем зеленый
			ldi temp,0b00000001			
			mov c_cicl,temp 			;задаем время свечения:1 цикл - 16 мс
			rcall delay 				;запускаем отсчет
			dec XH						;уменьшаем счетчик циклов цветов
			brne low_green
			clr XH						;чистим счетчик циклов цветов
			rjmp scan 					;уходим в сон		
	;*****Продолжается смена цветов. Второй блок: от зеленого к синему"
blue_c:		ldi XH,255
loop_bl:	inc blue 					;на единицу увеличиваем яркость blue
			dec green 					;на единицу уменьшаем green
			ldi temp,0b00000001			
			mov c_cicl,temp 			;задаем время свечения:1 цикл - 16 мс
			rcall delay 				;запускаем отсчет
			dec XH						;уменьшаем счетчик циклов цветов
			brne loop_bl
			clr XH						;чистим счетчик циклов цветов
	;*****Здесь место для блока проверки сенсора и уход в сон через затухание синего*****
	;*****Перед проверкой запретить прерывания*****
	;***** В этот момент синий диод продолжает светить!*****
			ldi temp,0b00000000
			out tccr0b,temp 			;стоп таймер
			cli 						;запрещаем прерывания
	;***** Опрашиваем сенсор *****		
			rcall scan_pro				
			clc 						;очищаем флаг С на всякий случай
			cp sensWork,sensLow 		;сравниваем показания сенсора с калибровочным 
			brlo blue_sleep				;идем спать
			ldi temp,0b00000001			
			out tccr0b,temp				;запускаем таймер
			sei							;разрешаем прерывания
			rjmp bl_red_c 				;перескакиваем на продолжение свечения
	;***** Если касания в зеленом цикле не обнаружено,
	;уменьшаем в ноль зеленый и засыпаем *****
blue_sleep: ldi temp,0b00000001			
			out tccr0b,temp				;запускаем таймер
			sei							;разрешаем прерывания
			ldi XH,255
low_blue:	dec blue 					;на единицу уменьшаем зеленый
			ldi temp,0b00000001			
			mov c_cicl,temp 			;задаем время свечения:1 цикл - 16 мс
			rcall delay 				;запускаем отсчет
			dec XH						;уменьшаем счетчик циклов цветов
			brne low_blue
			clr XH						;чистим счетчик циклов цветов
			rjmp scan 					;уходим в сон				
	;*****Продолжается смена цветов. Третий блок: от синего к красному"
bl_red_c:	ldi XH,255
loop_re:	inc red 					;на единицу увеличиваем яркость red
			dec blue 					;на единицу уменьшаем blue
			ldi temp,0b00000001			
			mov c_cicl,temp 			;задаем время свечения:1 цикл - 16 мс
			rcall delay 				;запускаем отсчет
			dec XH						;уменьшаем счетчик циклов цветов
			brne loop_re
			clr XH						;чистим счетчик циклов цветов
			rJMP	main
				
; End Main =================================================================


; Procedure ================================================================
	;*****Подпрограмма отсчета промежутка для стартового моргания светодиода*****
delay:		ldi delayL,timeL			;загружаем мл.регистр 
			ldi delayM,timeM			;загружаем ср.регистр
			ldi delayH,timeH			;загружаем ст.регистр
time:		subi delayL,1				;отсчет 16 мс паузы. 
			sbci delayM,0				
			sbci delayH,0
			brcc time
			dec c_cicl					;уменьшаем счетчик циклов на 1
			brne delay					;пока не открутили заданное число циклов-в начало
			ret
	
	;***** Подрограмма сканирования сенсора *****
scan_pro:	mov sensWork,null			;чистим рабочее значение сенсора
			sbi ddrb,4					;переводим pb4 в режим выход
			cbi portb,4					;на всякий случай подаем туда 0 - разрядим сенсор
			ldi temp,0b00000001
			out tccr0b,temp 			;запускаем таймер на тактовой
			cbi ddrb,4 					;переводим pb4 во вход Hi-Z, начинается заряд сенсора
scan_4:		sbis pinb,4 				;проверяем 1 на входе pb4
			rjmp scan_4					;возврат на проверку, если < 1
			ldi temp,0b00000000
			out tccr0b,temp 			;стоп таймер
			sbi ddrb,4					;переводим pb4 в режим выход
			cbi portb,4					;подаем туда 0 - разрядим сенсор
			in sensWork,tcnt0			;считываем показания счетчика 
			out tcnt0,null 				;очищаем показания счетчика	
			ret
; End Procedure ============================================================


; EEPROM ===================================================================
	.ESEG								; Сегмент EEPROM
